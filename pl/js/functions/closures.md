# closures, замыкание

Замыкание - это когда одна функция вложена в другую, есть выражение которое имеет доступ к закрытым переменным в выражении. Вложенная функция - это и есть замыкание или замкнутая функция, она имеет доступ ко всем внутренним переменным

!!! Переменные объявленные внутри функции видны только внутри функции
!!! Может изменять значение внешних переменных, если внутри нет такой же переменной, меняет их после вызова функции, если внутри есть такая переменная, то не изменяет внешнюю.

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
a = addSquares(2, 3); // 13
b = addSquares(3, 4); // 25
c = addSquares(4, 5); // 41

// или
const outside = (x) => (y) => x + y;

fn_inside = outside(3);

result = fn_inside(5); // 8
result1 = outside(3)(5); // 8
```

Контекст выполнения – execution context – структура данных, которая содержит информацию о вызове функции включает в себя: место в коде, где находится интерпретатор, локальные переменные, значение this.
Один вызов – один контекст выполнения
При вложенном вызове происходит:

- выполнение текущей функции останавливается
- Её контекст запоминается в стеке контекстов
- Выполняется каждый вложенный вызов, для каждого из которого создается свой контекст
- после завершения старый контекст достается из стека и выполнение функция возобновляется с того места, где она была остановлена

## конфликты имен

```js
const outside = () => {
  var x = 5;
  return (x) => x * 2;
};

outside()(10); // возвращает 20 вместо 10
```

или

```js
var createPet = function (name) {
  // Внешняя функция определяет переменную с именем "name".
  return {
    setName: function (name) {
      // Внутренняя функция также определяет переменную с именем "name".
      name = name; // Как мы можем получить доступ к "name", определённой во внешней функции?
    },
  };
};
```

## Lexical Environment

у каждой функции, блок и скрипта есть связанный с ним внутренний объект – Lexical Environment, который состоит из:

- Environment Record – объект в котором хранятся локальные переменные и такие вещи как this. Переменная в свою очередь – это свойство этого объекта ER. Получить или изменить переменную = получить или изменить свойство этого внутреннего объекта.
- Ссылка на внешнее логическое окружение – то, что находится за скобками { }

Переменная - это свойство внутреннего объекта Lexical Environment. Получить или изменить переменную, означает получить или изменить это свойство, с этим LE идет в паре ссылка outer либо на ноль , либо на другое LE

В процессе вызова функции есть два лексических окружения внутреннее (для вызываемой функции) и внешнее (глобальное). Если переменная не была найдена, то в strict modе это будет ошибкой, а без strict mode создается глобальная переменная.

один вызов – одно лексическое окружение

Все функции, при рождении получают свойство Environment, которое ссылается на лексическое окружение
места, где он были созданы. Другими словами это свойство - ссылка на лексическое окружение

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. Они автоматически запоминают место, где были созданы, с помощью свойства Environment и все они могут получить доступ к внешним переменным.

## блоки кода

```js
// if
let phrase = "hello";
if (true) {
  let user = "John";
  alert(`${phrase}${user}`);
}
alert(user); //Error, no such variable т.к. переменная user существует только в блоке кода if

// for, while
for (let i = 0; i < 10; i++) {
  //у каждой итерации цикла свое собственное лексическое окружение
}
alert(i); //Ошибка

// Блоки кода
{
  let message = "Hello";
  alert(message); //hello
}
alert(message)(
  //ошибка

  // IIFE immediately invoked function expression

  function () {
    let message = "Hello";
    alert(message);
  }
)(); // вызовется сразу
// TG;
let result = 2009;
(function (value) {
  delete value;
  if (value) {
    result = value;
  }
})(262); // 262, при use strict будет ругаться на delete value – удаление value из глобального объекта
```
