# if

Оператор if синтаксис:

```js
if(
  // условие
  ){
    // код;
    }
```

# if else

```js
let year = prompt("В каком году появилась спецификация ECMAScript-2015?", "");
if (year < 2015) {
  alert("Это слишком рано...");
} else if (year > 2015) {
  alert("Это поздновато");
} else {
  alert("Верно!");
}
```

# оператор ?

синтаксис: let x = ( условие )? значение1 : значение2
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2

Несколько операторов ? Let x = (cond 1) ? Value1 : (cond2)? : value2 : (cond3) ? Value3 : value4

# Оператор «ИЛИ» ||

Находит первое истинное значение и ← его, если все ложные, то ← последний, синтаксис: Result = a||b||c

# Оператор «и» &&

Находит первый false и ← его, если все истинные, то ← последний

# Оператор !

Приводит к логическому типу и противоположное значение !! Используют для преобразование в логический тип

# Оператор??

Результат выражения a ?? b будет следующим: «a», если значение a определено, «b», если значение «a» не определено.
Передача логического значения в переменную: Let condition = (year == 2005)

Оператор ?? следует заключать в скобки

```js
let x = 1 && 2 ?? 3; //синтаксическая ошибка

let x = (1 && 2) ?? 3; // 2

const result = 0 || 10 && 20 || 30; //первое сравнение 10 && 20 вернет 20
console.log(result);//20
```

## BP. Операторы ?? и || с потенциально числовыми значениями

```js
// неправильно
const incorrect = { amount: smzReceipt?.amount / 100 ?? "" }; //если smzReceipt?.amount / 100 === NaN то вернет NaN
// правильно
const correct = { amount: smzReceipt?.amount / 100 || "" }; //Так как если слева NaN
```

## BP. Ошибка в обращении к полям после проверки на undefined

```js
// если есть проверка
hasError = Boolean(error?.message);
// далее - неправильно, лишний опциональный оператор
hasError && error?.message;
// так как проверили то можно
hasError && error.message;
```

# Bytes operators

Побитовое И & - равен единице, когда оба оператора равны единице
Побитовое или |- равен единице, когда один из операторов равен единице

^ исключающее или - равен единице, когда один из равен единице, но не оба a ^ b ^ b = a полезно для шифрования с ключом
~ НЕ – меняет 0 на 1 и наоборот

```js
// из-за внутреннего представления отрицательных чисел ~n== -(n+1)

alert(~3); //-4  alert(~~1)//0
```

a << b Битовый сдвиг влево – сдвигает влево b бито в числе a заполняя b - нулями справа соответствует умножению на 2 b-раз

a >> b побитовый сдвиг вправо – соответствует делению на 2 b-раз

# Унарная запятая

```js
let x = 1;
x = (x++, x);
console.log(x); //со скобками 2 без скобок 1
x = (2, 3);
console.log(x); //со скобками 3 без скобок 2
```

# Логическое присваивание

```js
const a = 50;
const b = "";

a ||= 10;
//теперь  a === 50  так как true

b ||= "empty string";

//  b === "empty string"
```

# with

Последующее использование with указывает что Объект Math является объектом по умолчанию

```js
var a, x, y;
var r = 10;

with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
```
