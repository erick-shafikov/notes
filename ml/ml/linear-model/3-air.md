# вычисление показателя качества

- вычислить значение показателя качества Q

```python
import numpy as np


def func(x):
    return 0.1 * x ** 2 - np.sin(x) + 0.1 * np.cos(x * 5) + 1.


# здесь объявляйте дополнительные функции (если необходимо)


coord_x = np.arange(-5.0, 5.0, 0.1)  # значения отсчетов по оси абсцисс
coord_x_1 = np.arange(-5.0, 5.0, 0.1).reshape(-1, 1)  # второй вариант для матричного умножения
coord_y = func(coord_x)  # значения функции по оси ординат

sz = len(coord_x)  # общее число отсчетов

# здесь продолжайте программу
w = [1.11, -0.26, 0.061, 0.0226, 0.00178]
w.reverse()
y_model = np.polyval(w, coord_x)
Q = np.mean((coord_y - y_model) ** 2)
# OR ####################################################################
w = np.array([1.11, -0.26, 0.061, 0.0226, 0.00178]).reshape(-1, 1)
X = np.power(coord_x_1, np.arange(5))
Q1 = np.square(X @ w - coord_y).mean()
```

- вычислить значение показателя качества Q (модуль)

```python
import numpy as np


def func(x):
    return 0.5 * x ** 2 - 0.1 * 1 / np.exp(-x) + 0.5 * np.cos(2 * x) - 2.


# здесь объявляйте дополнительные функции (если необходимо)
w = np.array([-1.59, -0.69, 0.278, 0.497, -0.106])


def model(coord_x):
    return np.column_stack([np.ones_like(coord_x), coord_x, coord_x ** 2, np.cos(2 * coord_x), np.sin(2 * coord_x)]) @ w


coord_x = np.arange(-5.0, 5.0, 0.1)  # значения отсчетов по оси абсцисс
coord_y = func(coord_x)  # значения функции по оси ординат

sz = len(coord_x)  # общее число отсчетов
print(model(coord_x))
# здесь продолжайте программу
Q = np.abs(coord_y - model(coord_x)).mean()
```

# вычисление разделяющий гиперплоскости

- вычисление значения w для квадратичной функции

```python
import numpy as np

data_x = [(5.8, 1.2), (5.6, 1.5), (6.5, 1.5), (6.1, 1.3), (6.4, 1.3), (7.7, 2.0), (6.0, 1.8), (5.6, 1.3), (6.0, 1.6),
          (5.8, 1.9), (5.7, 2.0), (6.3, 1.5), (6.2, 1.8), (7.7, 2.3), (5.8, 1.2), (6.3, 1.8), (6.0, 1.0), (6.2, 1.3),
          (5.7, 1.3), (6.3, 1.9), (6.7, 2.5), (5.5, 1.2), (4.9, 1.0), (6.1, 1.4), (6.0, 1.6), (7.2, 2.5), (7.3, 1.8),
          (6.6, 1.4), (5.6, 2.0), (5.5, 1.0), (6.4, 2.2), (5.6, 1.3), (6.6, 1.3), (6.9, 2.1), (6.8, 2.1), (5.7, 1.3),
          (7.0, 1.4), (6.1, 1.4), (6.1, 1.8), (6.7, 1.7), (6.0, 1.5), (6.5, 1.8), (6.4, 1.5), (6.9, 1.5), (5.6, 1.3),
          (6.7, 1.4), (5.8, 1.9), (6.3, 1.3), (6.7, 2.1), (6.2, 2.3), (6.3, 2.4), (6.7, 1.8), (6.4, 2.3), (6.2, 1.5),
          (6.1, 1.4), (7.1, 2.1), (5.7, 1.0), (6.8, 1.4), (6.8, 2.3), (5.1, 1.1), (4.9, 1.7), (5.9, 1.8), (7.4, 1.9),
          (6.5, 2.0), (6.7, 1.5), (6.5, 2.0), (5.8, 1.0), (6.4, 2.1), (7.6, 2.1), (5.8, 2.4), (7.7, 2.2), (6.3, 1.5),
          (5.0, 1.0), (6.3, 1.6), (7.7, 2.3), (6.4, 1.9), (6.5, 2.2), (5.7, 1.2), (6.9, 2.3), (5.7, 1.3), (6.1, 1.2),
          (5.4, 1.5), (5.2, 1.4), (6.7, 2.3), (7.9, 2.0), (5.6, 1.1), (7.2, 1.8), (5.5, 1.3), (7.2, 1.6), (6.3, 2.5),
          (6.3, 1.8), (6.7, 2.4), (5.0, 1.0), (6.4, 1.8), (6.9, 2.3), (5.5, 1.3), (5.5, 1.1), (5.9, 1.5), (6.0, 1.5),
          (5.9, 1.8)]
data_y = [-1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1,
          -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1,
          1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
          -1, -1, -1, -1, 1]

# массив вида [1, x1, x2] из data_x
train_x = np.hstack((np.ones((len(data_x), 1)), np.array(data_x)))
train_y = np.array(data_y)

X = train_x
y = train_y

w = np.linalg.inv(X.T @ X) @ X.T @ y
```

Пример 2

```python
import numpy as np
import matplotlib.pyplot as plt

x_train = [[10, 50], [20, 30], [25, 30], [20, 60], [15, 70], [40, 40], [30, 45], [20, 45], [40, 30], [7, 35]]
x_train = [x + [1] for x in x_train]
x_train = np.array(x_train)
y_train = np.array([-1, 1, 1, -1, -1, 1, 1, -1, 1, -1])

pt = np.sum([x * y for x, y in zip(x_train, y_train)], axis=0)
xxt = np.sum([np.outer(x, x) for x in x_train], axis=0)
w = np.dot(pt, np.linalg.inv(xxt))
```
