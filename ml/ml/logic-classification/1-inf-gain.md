# Inf gain

расчет коэффициента IG с помощью коэффициент Джинни

```python
import numpy as np

np.random.seed(0)
X = np.random.randint(0, 2, size=200) # генерация выборки

t = 150


def get_gini(x): # расчет коэффициента Джинни
    _, counts = np.unique(x, return_counts=True)
    p = counts / counts.sum()

    return 1 - np.sum(p ** 2)


x11 = X[:t] # берем до критерия
x12 = X[t:] # после критерия

S1 = len(x11) / len(X) * get_gini(x11) + len(x12) / len(X) * get_gini(x12) # расчет после сортировки

IG = get_gini(X) - S1 # расчет суммарного коэффициент
```

- вычисление наибольшего информационного выигрыша на одной итерации, с учетом признака (первая или вторая координата)

```python
import numpy as np

data_x = [(5.8, 2.7), (6.7, 3.1), (5.7, 2.9), (5.5, 2.4), (4.8, 3.4), (5.4, 3.4), (4.8, 3.0), (5.5, 2.5), (5.3, 3.7),
          (7.0, 3.2), (5.6, 2.9), (4.9, 3.1), (4.8, 3.0), (5.0, 2.3), (5.2, 3.4), (5.1, 3.8), (5.0, 3.0), (5.0, 3.3),
          (4.6, 3.1), (5.5, 2.6), (5.0, 3.5), (6.7, 3.0), (6.0, 2.2), (4.8, 3.1), (6.4, 2.9), (5.6, 3.0), (4.4, 3.0),
          (4.9, 2.4), (5.6, 3.0), (5.0, 3.6), (5.1, 3.3), (5.8, 4.0), (5.5, 2.4), (5.2, 2.7), (5.1, 3.8), (5.1, 3.5),
          (5.5, 4.2), (4.9, 3.1), (5.9, 3.2), (5.7, 2.6), (4.7, 3.2), (5.4, 3.9), (5.8, 2.6), (5.1, 3.4), (6.4, 3.2),
          (5.8, 2.7), (5.6, 2.7), (5.7, 2.8), (5.4, 3.0), (5.0, 3.2), (4.6, 3.4), (6.0, 2.7), (6.6, 3.0), (4.9, 3.0),
          (4.9, 3.6), (4.4, 3.2), (5.4, 3.4), (6.0, 3.4), (5.9, 3.0), (6.1, 2.8), (5.1, 3.7), (5.5, 3.5), (6.1, 3.0),
          (6.2, 2.2), (5.7, 3.0), (5.2, 3.5), (5.4, 3.7), (4.6, 3.2), (5.2, 4.1), (5.0, 2.0), (6.8, 2.8), (5.0, 3.5),
          (6.7, 3.1), (6.3, 3.3), (6.0, 2.9), (4.7, 3.2), (6.6, 2.9), (5.6, 2.5), (4.4, 2.9), (6.2, 2.9), (6.1, 2.9),
          (4.3, 3.0), (6.9, 3.1), (5.7, 3.8), (5.4, 3.9), (6.1, 2.8), (4.6, 3.6), (5.5, 2.3), (4.8, 3.4), (6.5, 2.8),
          (6.3, 2.5), (5.1, 3.8), (5.7, 4.4), (5.0, 3.4), (4.5, 2.3), (5.7, 2.8), (5.1, 2.5), (5.1, 3.5), (6.3, 2.3),
          (5.0, 3.4)]
data_y = [1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1, -1,
          -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, -1,
          1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, -1, -1,
          -1, 1, 1, -1, 1, -1]

x_train = np.array(data_x)
y_train = np.array(data_y)


def get_gini(x):
    _, counts = np.unique(x, return_counts=True)
    p = counts / counts.sum()

    return 1 - np.sum(p ** 2)


X = np.vstack([x_train.T, data_y]).T
S0 = get_gini(X[:, -1])
th = -np.inf
IG = -np.inf
fj = None

for j in [0, 1]:
    range_t = np.arange(min(x_train[:, j]) + 0.1, max(x_train[:, j]) - 0.1, 0.1)
    for t in range_t:
        x_left = X[X[:, 0] < t]
        x_right = X[X[:, 0] > t]

        S1 = len(x_left) / len(X) * get_gini(x_left[:, -1]) + len(x_right) / len(X) * get_gini(x_right[:, -1])

        IG, th, fj = (S0 - S1, t, j) if S0 - S1 > IG else (IG, th, fj)
```
