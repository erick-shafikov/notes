```python
# Аппроксимация данных ядерным сглаживанием

import numpy as np

x = np.arange(0, 10, 0.1)  # отсчеты для исходного сигнала
x_est = np.arange(0, 10, 0.01)  # отсчеты, где производится восстановление функции
N = len(x)
y_sin = np.sin(x)
y = y_sin + np.random.normal(0, 0.5, N)

# аппроксимация ядерным сглаживанием
h = 1.0  # при окне меньше 0.1 для финитных ядер будут ошибки

# выбор ядра
K = lambda r: np.exp(-2 * r * r)  # гауссовское ядро
# K = lambda r: np.abs(1 - r) * bool(r <= 1) # треугольное ядро
# K = lambda r: bool(r <= 1)  # прямоугольное ядро

ro = lambda xx, xi: np.abs(xx - xi)  # метрика
w = lambda xx, xi: K(ro(xx, xi) / h)  # веса

# варианты для разных h
# for h in [0.1, 0.3, 1, 10]:
y_est = []
for xx in x_est:
    ww = np.array([w(xx, xi) for xi in x])
    yy = np.dot(ww, y) / sum(ww)  # формула Надарая-Ватсона
    y_est.append(yy)


```

- прогноз по модели

```python
import numpy as np

rub_usd = [75, 76, 79, 82, 85, 81, 83, 86, 87, 85, 83, 80, 77, 79, 78, 81, 84]

# здесь продолжайте программу
h = 3

K = lambda r: 1 / (2 * np.pi) ** .5 * np.exp(- r ** 2 / 2)
ro = lambda xx, xi: np.abs(xx - xi)  # метрика
w = lambda xx, xi: K(ro(xx, xi) / h)  # веса

length = len(rub_usd)
train_x = list(rub_usd)
predict = []

for i in range(10):
    ww = np.array([w(i + length, x) for x in range(i + length)])
    yy = np.dot(ww, train_x + predict) / sum(ww)

    predict.append(yy)

print(predict)

```