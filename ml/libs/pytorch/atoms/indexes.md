```python
import torch

a = torch.tensor(12)

# обращение
a_2 = a[2]
a_last = a[-1]
# получить значение, а не тензор
a_2_value = a_2.item()
# срез
a24 = a[2:4]  # данные одинаковые
a_3_last = a[3:]
a_all = a[:]  # все
a162 = a[1:6:2]
a__1 = a[::-1]
# присвоение
a[:4] = torch.IntTensor([1, 2, 3, 4])  # должно совпадать количество элементов
```

# Двумерные массивы

```python
import torch

# двумерные массивы
x = torch.InitTensor([(1, 2, 3), (4, 5, 6), (7, 8, 9)])
x11 = x[1, 1]
x_last = x[-1, -1]
# срезы вложенных
x__1 = x[:, 1]
x__some = x[0:2, 0:2, 1, 1]
xx_last = x[..., 1, 1]
# списочная индексация
x_copy = x[[0]]  # возьмет по индексам
x_copy1 = x[torch.Int([0, 0, 1, 1, 2])]  # копии
# с булевым тензером
bool_index = torch.BoolTensor([True, False, False])
x_bool = x[bool_index]  # возьмет только те, которые True по индексу
# присвоить элементам [0,1], [1,4] и [2, 5] значение 1
x[[0, 1, 2], [3, 4, 5]] = 1

# фильтрация
i = x > 5  # вернет булевый тензор
more_than_5 = x[x > 5]  # вернет все кто больше 5
t_res = x[(x >= -2) & (x <= 2)]  # два условия
```