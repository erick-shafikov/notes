# типы

- torch.
- - float16 - с плавающей точкой
- - float32
- - float64
- - int16 - целые
- - int32
- - int64
- - int8
- - unit8
- - bool

# создание

```python
import numpy as np
import torch
from numpy.conftest import dtype

# тензоры должны быть равных размерностей

# создание пустого 3 * 5 * 2 тензора
t = torch.empty(3, 5, 2)
# все будет float
torch.tensor([1, 2.0, 0])
# явное указание
torch.tensor([1, 2, 0], dtype=torch.float32)
# типизированный тензор
torch.ByteTensor([1, 2])
torch.DoubleTensor([1, 2, 3])
# torch.FloatTensor 32 бита, с плавающей точкой
# torch.DoubleTensor 64 бита, с плавающей точкой
# torch.IntTensor 32 бита, целочисленный, знаковый
# torch.LongTensor 64 бита, целочисленный, знаковый
# torch.BoolTensor булевый (True/False)
```

# Свойства и атрибуты тензоров

```python
import torch

t = torch.empty(3, 5, 2)

# атрибут, содержащий тип данных тензора
t.dtype
# атрибут, содержащий размерность тензора
t.shape

# методы
# метод, возвращающий класс тензора (FloatTensor, LongTensor и т.п.)
t.type()
# метод, возвращающий размерность тензора по всем осям
t.size()
torch.shape()
# метод, возвращающий число осей тензора
t.dim()


# изменения типов данных на лету
t = t.float()  # half, float, double, short
# float() == torch.float32
# double() == torch.float64
# int() == torch.int32
# long() == torch.int64
# char() == torch.int8
# byte() == torch.uint8
# bool() == torch.bool
```

# Взаимодействие с np

```python
import torch
import numpy as np

# взаимодействие с np
# преобразование из np.array
d_np = np.array([1, 2, 3])
# не копирует, создает с той же размерностью, будет завязан с np массивом
t2 = torch.from_numpy(d_np)
# копирует значения, но списки копируются
t3 = torch.tensor(d_np)
# обратное преобразование (но не копия, а ссылка)
d_linked = t2.numpy()
# обратное преобразование (с копией)
d_unlinked = t2.numpy().copy()
```

# Создание и заполнение

```python
import torch

# создание тензоров
# создаст 2 * 3 тензор с нулями
tz_zero = torch.zeros(2, 3, dtype=torch.int32)
# создаст 2 * 3 тензор с единицами
tz_ones = torch.ones(2, 3, dtype=torch.int32)
# создаст 3 * 3 тензор с единицами по главной диагонали
tz_eye = torch.eye(3)
tz_eye2 = torch.eye(3, 2, dtype=torch.int32)  # матрица 3 на 2 с единицами по диагонали

# создать тензор 2 на 4 и заполнить значением 5
tz_full = torch.full((2, 3), 5)
```

# последовательности

```python
import torch

# создание последовательностей
# АП от 0 до 6
range_ap = torch.arange(7)
range_ap2 = torch.arange(-5, 0)  # АП от -5 до 0
range_ap3 = torch.arange(-5, 0, 2)  # с шагом может быть отрицательный

# создаст тензор [1,3,5] начало/старт/шаг разобьет до 1 до 3 на 5 отрезков
torch.linspace(1, 5, 2)
```

# Создание последовательностей

- равномерное распределение:
- - torch.rand() - формирует тензор с заданными размерами, состоящий из равномерно распределенных ПСВ в диапазоне [0; 1)
- - torch.randint(low, high, size, dtype=None, layout=torch.strided, device=None, requires_grad=False) - формирует тензор с заданными размерами, состоящий из равномерно распределенных целых ПСВ в заданном диапазоне [a; b)

- нормальное распределение:
- - torch.randn(size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) - формирует тензор с заданными размерами, состоящий из нормально распределенных ПСВ с нулевым средним и единичной дисперсией
- - torch.normal(mean, std, generator=None, out=None) - формирует тензор с заданными размерами, состоящий из нормально распределенных ПСВ с указанным средним и указанной дисперсией

```python
import torch

# создание произвольных последовательностей
# создание последовательностей с заданным распределением
torch.rand(2, 3)
# размером (21), типом torch.float32, состоящий из равномерно распределенных ПСВ в диапазоне [0; 1);
t1 = torch.rand(21, dtype=torch.float32)
# размером (3, 5), типом torch.int16, состоящий из равномерно распределенных целых ПСВ в диапазоне [-5; 5] (включая обе границы);
t2 = torch.randint(low=-5, high=6, size=(3, 5), dtype=torch.int16)
torch.randn(2, 3)  # нормально распределенные данные с 0 среднем и единичной дисперсией
# размером (64, 128), типом torch.float64, состоящий из нормально распределенных ПСВ с нулевым средним и единичной дисперсией.
t3 = torch.randn(64, 128, dtype=torch.float64)

# задание зерна последовательности
torch.manual_seed(0)

```

# Inplace методы\_

Inplace методы меняют содержимое самого тензора, не создавая нового:

- t.random\_() - заполнение тензора t равномерно распределенными дискретными ПСВ в диапазоне [a; b)
- t.uniform\_() - заполнение тензора t равномерно распределенными непрерывными ПСВ в диапазоне [a; b)
- t.normal\_() -заполнение тензора t нормально распределенными ПСВ с указанным средним mean и стандартным отклонением std

```python
import torch

# функции и методы с _ на конце не создают
# ф-ции и методы без _ создают новый
x = torch.FloatTensor(2, 4)
# все четверки поменяет на 1 в x
x.fill_(1)

# заполнить нулями
x0 = torch.FloatTensor(2, 4).zero_()

# преобразования тензора
x.uniform_(1, 7)  # заполнение тензора t равномерно распределенными непрерывными ПСВ в диапазоне [a; b)
x.uniform_(0, 1)  # заполнение тензора равномерно распределенными дискретными ПСВ в диапазоне [a; b)
# размером (3, 10, 2), состоящий из равномерно распределенных непрерывных ПСВ в диапазоне [-2; 10)
t1 = torch.Tensor(3, 10, 2).uniform_(-2, 10)
# заполнение тензора нормально распределенными ПСВ с указанным средним mean и стандартным отклонением st
x.normal_(0, 1)
# размером (123), состоящий из равномерно распределенных целых ПСВ в диапазоне [13; 19] (включая обе границы)
t2 = torch.Tensor(123).random_(13, 20)
# размером (8, 1024), состоящий из нормально распределенных ПСВ со средним 23 (mean=23) и стандартным отклонением 50 (std=50)
t3 = torch.Tensor(8, 1024).normal_(mean=23, std=50)


```

# Представления тензоров

```python
import torch

# представления тензоров работают с одним и тем же набором данных
tz27 = torch.arange(27)  # тензор от 0 до 26
tz3_9 = tz27.view(3, 9)  # тензор 3 на 9, используют одинаковые данные
tz3_3_3 = tz27.reshape(3, 3, 3)  # чаще используется view


tz27.resize_(2, 3)  # оставит только 2 на 3, view работает с тем же количеством элементов, без ошибок

# получить одномерный вектор
tz27.ravel()

# транспонирование
tz3_9.permute(1, 0)  # поменять оси местами (9 на 3)
tz9_3 = tz3_9.mT  # поменять оси местами (9 на 3)
```

# Добавление и удаление осей

- t.ravel() - возвращает одномерное представление тензора t (вытягивает в вектор)
- t.permute() - создает новое представление тензора t с измененным порядком осей
- t.mT - возвращает транспонированное представление тензора t
- t.unsqueeze() - возвращает новое представление, в котором добавляет новую ось с указанным номером
- t.squeeze() - возвращает новое представление, в котором удаляет указанную ось (либо все оси), если на ней всего один
  элемент

```python
import torch

# добавление
tz_to_squeeze = torch.arange(32).view(8, 2, 2)
# к tz_to_squeeze добавить ось, ны выходе (8, 2, 2) -> (1, 8, 2, 2)
tz_to_squeeze1 = torch.unsqueeze(tz_to_squeeze, dim=0)
# на самом тензоре
tz_to_squeeze.unsqueeze(0)
# или поменять сам тензор
tz_to_squeeze.unsqueeze_(0)
# добавить в конец
tz_to_squeeze2 = torch.unsqueeze(tz_to_squeeze, dim=-1)
# удаление только те измерения, где один элемент
torch.squeeze(tz_to_squeeze1)

```
