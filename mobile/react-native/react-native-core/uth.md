# архитектура

## Старя архитектура:

За сборку приложения отвечают следующие модули:

- BUCK - мультиплатформенная система сборки
- Metro bundler - сборщик JS написаный специально для React Native
- React Native CLI - набор утилит для сборки приложения под конкретную платформу

Во время выполнения обязательными являются:

- JS Core или Hermes - движки на которых запускается JS код
- Yoga layout - кросс платформенный менеджер компоновки с синтаксисом близки к css flex box
- ReactJS и React Native - ядро приложения, отвечают за рендеринг на стороне JS и взаимодействие с нативным слоем

схема:

react -> js thread[js-core (js-bundle)] <-> bridge <-> Native|UI thread <-> Shadow thread (Yoga)

При нажатии кнопки:

- ользователь нажимает на иконку приложения
- Native Thread загружаешь все нативные зависимости и модули
- Native Thread стартует JS Thread который загружает собраный js bundle
- JS Thread посылает сериализованное сообщение через Bridge о том как отрисовать UI на нативной стороне.
- Shadow Thread получает эти сообщения и формирует UI Tree
- На базе UI Tree менеджер компоновки Yoga формирует нативные компоненты с размерами для конкретной платформы и устройства и передает на отрисовку в Native Thread
- Native Thread отрисовывает компоненты на экране.

## новая архитектура

- JSI - JavaScript Interface замена для Bridge. С помощью JSI можно напрямую взаимодействовать с нативными модулями избегая накладных расходов на пересылку сообщений
- Fabric - новая система рендеринга пришедшая на замену UIManager
- Turbo Modules - в текущей архитектуре все модули для работы с нативной функциональностью (Bluetooth, Geo, Camera и т.д.) должны быть загружены во время старта приложения.
- CodeGen - упрощает создание нативных интерфейсов для работы с Turbo Modules и Fabric

- react компоненты переводятся в нативные компоненты
- логика воспроизводится в js

Фабрика - это система рендера React. Которая помогает решить такие проблемы как: синхронность, интеграция React Suspense, React concurrent фишки. Весь код компилирует в C++ код. Фазы: Render (js производит shadow tree которое преобразуется в С++), Commit (стадия изменения, формируется новое дерево), Mount (преобразуется в host view tree)

- Render: при создании элемента с помощью React Element вызывается React Shadow Node. Это случает только для React Host Component но не для React Composite Component.
- Commit: при изменении вызывается Yoga, которая позволяет произвести вычисления. Tree Promotion - стадия на которой, новой дерево отрисовывается. Операция асинхронная. Новое дерево отрисуется на следующий тик
- Mount: React Shadow Tree превращается в Host View Tree, отображая пиксели. Tree Diffing - стадия вычисления разницы, Tree Promotion - добавление разницы, View Mounting- отрисовка

Схема работы кросс-платформы

<img src='./assets/react-native/cross-plat.png' height=200 width=300/>

Используются View Flattening - для работы со вложенными компонентами

Headless JS - это то как запускаются задачи в JS, пока приложение свернуто

# Запуск проекта

- с помощью expo или sdk
