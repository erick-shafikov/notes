# компоненты

## server-components

Три стратегии рендеринга серверных компонентов:

- Статический
- Динамический
- Стримминг

Преимущества: Перенос запроса за данными на сторону сервера, безопасность, размер сборки,
FCP, Оптимизация для поисковиков, Стримминг

Как происходит рендеринг на сервере

- Приложение рендерится в разные чанки по роутам и по suspense
- React рендерит проект в специальном формате React Server Component Payload (RSC Payload).
- RSC в свою очередь - это бинарные файлы, которые включают в себя: Макеты для верстки и ссылки на JS,
- все пропсы, которые передаются из серверных к клиентским в качестве props
- Next.js использует RSC Payload и клиентские компоненты в JS И рендерит их в JS

На клиенте:

- Отображается неинтерактивный контент по роуту
- React согласовывает DOM клиентских компонентов и серверных и обновляет DOM
- Далее JS использует гидратацию данных, делая компоненты интерактивными

Стратегии серверного рендеринга

- Статичный рендеринг - по умолчанию, приложение собирается на сервере
- Динамический - собирается по запросу, используются функции cookies(), headers(), searchParams()
- Стримминг - когда контент подгружается параллельно

Преимущества при использовании server components

- имеет прямой доступ к BE (db например)
- Более безопасное хранение токенов
- Лучшая коммуникация между BE и FE
- Однонаправленный поток запросов
- Уменьшает зависимость между запросами
- Уменьшается задержка

## client-components

- интерактивные (можно использовать useEffect, useState)
- Использовать браузерное api (localStorage)
- использование с помощью useClient

  Сначала на сервере:

  - react рендерит все в виде RSC Payload
  - Next использует RSCP для генерации HTML

  На клиенте:

  - отображается не интерактивный контент
  - RSCP использует согласование для создания DOM
  - Использует гидратация для интерактивности

## <Image />

Для удаленных нужно добавлять в next.config

```js
//next.config
images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "miro.medium.com",
        port: "",
        pathname: "/**",
      },
    ],
  },

```

- priority – проп позволяет протезировать изображение при загрузке
- fill – занимает полностью пространство родителя, если не задано, то у родителя position: relative, в противном случае изображение займет всю область экрана

## Font

```tsx
import { Roboto } from "next/font/google"; //импорт конкретного шрифта
const roboto = Roboto({ weight: ["300", "500"], subsets: ["latin"] }); //настройка

const Layout = () => <body className={roboto.className}></body>; //подключение
```

```tsx
// Возможно подключение нескольких шрифтов
// Подключение локальных шрифтов:
import localFont from 'next/font/local'

const myFont = localFont({
  src: './my-font.woff2',
  display: 'swap',
  variable: '--font-inter', //объявление в качестве переменной
})

<html lang="en" className={myFont.className}> </html>

```

## Link

Позволяет осуществить переход меду роутами. Основная фишка – пре-фетчинг данных
scroll={false} – если сбросить сохранение позиции при скролле

## lazy loading

```js
//объявление в качестве переменной
const LazyComponent = dynamic(() => import("../components/Lazy/Lazy"), {
  ssr: false,
  loading: () => <>Loading...</>,
});
```
