Работа с примитивами, как с объектами осуществляется через объект обертку, который создается на момент работы с примитивом
в момент обращения к свойству строки str создается специальный объект, который знает значение строки и имеет полезные методы такие как .toUpperCase()
Этот метод запускается и возвращает строку
Специальный метод удаляется, остается изменённый str

Конструкторы String/Number/Boolean предназначены только для внутреннего пользования, то есть через new Number(1) или new Boolean(false)

- Строки - массив символов
- Строки неизменяемы

```js
let str = "Привет":
str.test = 5;//undefined (без strict), Ошибка (strict)
// В момент обращения создается объект обертка
// В строгом режиме попытка изменения выдаст ошибку
// Без строго режима операция продолжиться, объект получит свойство test, но после этого оно удаляется

```

```js
alert(value); // преобразует значение к строке. undefined
```

Обратные – помимо функции вставки значения выражения, так же помогают растянуть на несколько строк
Для многострочного текста

```js
Let guestList = `Guest:
John
Pete
Mary
;
```

Перебор

```js
for (let char of "string") {
  //
}
```

# new String()

```js
//возвращает объект, что бы достать строку нужно вызвать
const objStr = new String();

String.prototype.isPrototypeOf(objStr); //достать строку из объекта-строки

objStr.toString();
var s = new String("foo"); // Создание объекта
console.log(s); // Отобразится: { '0': 'f', '1': 'o', '2': 'o'}
typeof s; // Вернёт 'object'
```

# toString()

если вызвать

```js
// то число будет переведено в систему исчисления
number.toString(2);
```

<!-- Методы строк ---------------------------------------------------------------------------------------------------------------------------->

# Методы строк

<!-- получение символа -->

## получение символа:

### length

Возвращает длину строки

### str[i]

символ на позиции в str, если символа нет undefined

### slice(start [, end])

строки от start до (не включая) end.

### substring(start [, end])

часть строки между start и end. (можно задавать start больше чем end) str.substr(start [, length]) ← часть строки от start длины length.

### codePointAt(pos)

код для символа, находящегося на позиции pos:

### charAt(), charCodeAt

at(-1) получить последний символ из строки
Если символа нет, то пустую строку

<!-- Поиск -->

## поиск:

### indexOf(substring, pos)

ищет подстроку substring в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.

### lastIndexOf(substr, position)

который ищет с конца строки к её началу.

### includes()

true, если в строке str есть подстрока substr, либо false, если нет. str.includes(substr, pos)

### startWith() и endsWith()

проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

## преобразование:

### toLowerCase(), toUpperCase()

Возвести в upper или lower case

### concat

объединяет строки

### trim()

удаляет пробелы с обоих концов строки. Пробелы — это все пробельные символы (пробел, табуляция, неразрывный пробел и т. д.) и все символы конца строки (LF, CR и т. д.). Обрати внимание, trim() удаляет пробелы только с краев.

### replace()

Синтаксис str.replace(regexp|substr, newSubstr|function[,flags]) ← новую строку с некоторыми или всеми сопоставлениями с шаблоном, замененным на заменитель

### repeat()

создает новую строку, повторяя заданную строку несколько раз, и возвращает ее. repeat() вызывает RangeError, если количество повторений отрицательное, равно бесконечности или превышает максимальный размер строки. Если используем параметр 0, возвращается пустая строка. При использовании нецелого числа значение преобразуется в ближайшее целое число с округлением вниз.

### split

разбивает строку на массив по заданному разделителю delim. есть необязательный второй числовой аргумент

```js
// необязательный числовой аргумент
let names = "Вася, Петя, Маша, Саша".split(", ", 2); // arr == ["Вася", "Петя"]
```

## Другие:

## fromCodePoint(code)

Создаёт символ по его коду code

## normalize

Возвращает нормализованную Unicode форму строки - значения объекта String, на котором вызывается.

<!-- unicode-символы ------------------------------------------------------------------------------------------------------------------------->

# unicode-символы

```js
"\xA9"; // "©"
"\u00A9"; // "©"
```

<!-- Тегерированные аргументы ---------------------------------------------------------------------------------------------------------------->

# Тегерированные аргументы

```js
//При использовании тегированных шаблонных литералов
//первым аргументом всегда будет массив строковых значений.
//Оставшимися аргументами будут значения переданных выражений!
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}
const person = "Lydia";
const age = 21;
getPersonInfo`${person} is ${age} years old`;
// в one – массив из пустой строки, так как начинается с параметра, потом " is "", потом разделенный строкой " years old"
// ['', ' is ', ' years old']
// в two – оправляется person
// в three - 21
```

# Сравнение строк

Intl.Collator позволяет отфильтровать в алфавитном порядке с учетом локали

```js
var names = ["Hochberg", "Hönigswald", "Holzman"];

var germanPhonebook = new Intl.Collator("de-DE-u-co-phonebk");

// as if sorting ["Hochberg", "Hoenigswald", "Holzman"]:
console.log(names.sort(germanPhonebook.compare).join(", "));
// logs "Hochberg, Hönigswald, Holzman"
```
