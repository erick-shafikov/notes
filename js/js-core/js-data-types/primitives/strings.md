JS – динамически типизируемый язык

Работа с примитивами, как с объектами осуществляется через объект обертку, который создается на момент работы с примитивом

в момент обращения к свойству строки str создается специальный объект, который знает значение строки и имеет полезные методы такие как .toUpperCase()
Этот метод запускается и возвращает строку
Специальный метод удаляется, остается изменённый str

Конструкторы String/Number/Boolean предназначены только для внутреннего пользования, то есть через new Number(1) или new Boolean(false)

# String

Строки - массив символов

!!! Строки неизменяемы

Обратные – помимо функции вставки значения выражения, так же помогают растянуть на несколько строк

```js
let str = "Привет":

alert( str.toUpperCase() ); //ПРИВЕТ

let str = "Hi";

str.test = 5;

alert(str.test); //undefined (без strict), Ошибка (strict)
// В момент обращения создается объект обертка
// В строгом режиме попытка изменения выдаст ошибку
// Без строго режима операция продолжиться, объект получит свойство test, но после этого оно удаляется

```

```js
alert(value); // преобразует значение к строке. ← undefined

String(value); // чтобы преобразовать значение к строке:
```

```js
Let guestList = `Guest:
John
Pete
Mary
;
```

```js
//возвращает объект, что бы достать строку нужно вызвать
const objStr = new String();

String.prototype.isPrototypeOf(objStr); //достать строку из объекта-строки
objStr.toString();
```

## toString() и числа

если вызвать

```js
// то число будет переведено в систему исчисления
number.toString(2);
```

## Методы строк

!!!TODO перевести в js

- str.at(-1) - получить последний символ из строки
- str.length Возвращает длину строки
- str[i] символ на позиции в str, если символа нет undefined
- str.charAt(pos) Получить символ, который занимает позицию pos. Если символа нет, то пустую строку
- Перебор for (let char of "string")
- toLowerCase(), toUpperCase() пример: alert( "Interface"[0].toLowerCase() ); // "i"
- str.IndexOf(substring, pos) ищет подстроку substring в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.
- str.lastIndexOf(substr, position), который ищет с конца строки к её началу.
- includes ← true, если в строке str есть подстрока substr, либо false, если нет. str.includes(substr, pos)
- str.startWith() и str.endsWith() проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:
- str.slice(start [, end]) ← строки от start до (не включая) end.
- str.substring(start [, end]) ← часть строки между start и end. (можно задавать start больше чем end) str.substr(start [, length]) ← часть строки от start длины length.
- str.codePointAt(pos) ← код для символа, находящегося на позиции pos:
- String.fromCodePoint(code) Создаёт символ по его коду code
- str.trim() - удаляет пробелы с обоих концов строки. Пробелы — это все пробельные символы (пробел, табуляция, неразрывный пробел и т. д.) и все символы конца строки (LF, CR и т. д.). Обрати внимание, trim() удаляет пробелы только с краев.
- str.repeat() - создает новую строку, повторяя заданную строку несколько раз, и возвращает ее. repeat() вызывает RangeError, если количество повторений отрицательное, равно бесконечности или превышает максимальный размер строки. Если используем параметр 0, возвращается пустая строка. При использовании нецелого числа значение преобразуется в ближайшее целое число с округлением вниз.
- split разбивает строку на массив по заданному разделителю delim. есть необязательный второй числовой аргумент
- replace(). Синтаксис str.replace(regexp|substr, newSubstr|function[,flags])
  ← новую строку с некоторыми или всеми сопоставлениями с шаблоном, замененным на заменитель

```js
let names = "Вася, Петя, Маша";
let arr = names.split(", ");
for (let name of arr) {
  alert(`сообщения получат ${name} `);
}

// необязательный числовой аргумент
let names = "Вася, Петя, Маша, Саша".split(", ", 2); // arr == ["Вася", "Петя"]
```

## Тегерированные аргументы

```js
//При использовании тегированных шаблонных литералов
//первым аргументом всегда будет массив строковых значений.
//Оставшимися аргументами будут значения переданных выражений!
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}
const person = "Lydia";
const age = 21;
getPersonInfo`${person} is ${age} years old`;
// в one – массив из пустой строки, так как начинается с параметра, потом " is "", потом разделенный строкой " years old"
// ['', ' is ', ' years old']
// в two – оправляется person
// в three - 21
```
