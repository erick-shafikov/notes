# ООП

Объектно-ориентированное программирование
Методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования

## Основные принципы ООП

- Полиморфизм – возможность работать с несколькими типами, будто это один и тот же тип. При этом поведение объектов будет
- Инкапсуляция – ограничение доступа к данным и возможностям их изменения
- Наследование – механизм, который позволяет описать новый класс на основе существующего (родительского) При этом свойства и функциональность родительского класса заимствуется новым классом
- Абстракция – выделение главных наиболее значимых характер предмета и наоборот – отбрасывание второстепенных, незначительных

# ПАТТЕРНЫ

Типичные способы решения часто встречающихся проблем при проектировании программ

использовать:

- Во время проектирования ПО
- Если использование оправдано и целесообразно
- Если работает большое количество людей над проектом, для стандартизации

## Классификация

**Порождающие** паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей

**Структурные паттерны**  которые были разработаны, чтобы решить проблемы, связанные с структурой объектов или классов, показывают различные способы построения зависимостей

**Поведенческие** – заботятся об эффективной коммуникации между объектами

### Порождающие:

**Abstract Factory** Предоставляет метод фабрики для создания объектов или классов, которые связаны или зависимы, не уточняя конкретный класс. Factory.CreateProductA(); Factory.CreateProductB();

**Factory Method** Определяет интерфейс для создания объекта, при этом позволяет решить, какие подклассы класса используются для создания экземпляра. FactoryA.Create(); FactoryB.Create();

**Builder** Отделяет создание объекта от его представления, так что о бъект может поддерживать различные представления. Builder.BuildPartA(); Builder.BuildPartB(); Build.GetFinalProduct();

**Prototype** Указывает тип объектов, который необходимо создать с помощью примера прототипа и создает новые объекты путем копирования этого прототипа. Product = Prototype.Clone();

**Singleton** Предоставляет для доступа к экземпляру класса одну общую точку, например статический метод. Singleton.DoSomething();

### Структурные:

**Adapter** Преобразует интерфейс класса в другой интерфейс, который клиенты ожидают. Target obj = new Adapter(); obj.DoSomething();

**Bridge** Отделяет абстракцию от ее реализации, так что они могут изменяться независимо. var obj = new ConcreteA(); obj.DoSomething(); obj = new ConcreteB(); obj.DoSomething();

**Composite** Добавляет объекты в древовидные структуры для представления сложных иерархий. Composite.Add(objA); Composite.Add(objB);

**Decorator** Динамически расширяет используемый объект. obj.SetDecorator(decA); obj.DoDecoration(); obj.SetDecorator(decB); obj.DoDecoration();

**Façade** Предоставляет унифицированный интерфейс для включения других интерфейсов в подсистеме. Façade.MethodFromObjA(); Façade.MethodFromObjB();

**Flyweight** Структурирует множество объектов путем инкапсуляции логики их создания в одном объекте.
A = FWFactory.GetFW("A"); B = FWFactory.GetFW("B");

**Proxy** Является заполнителем для другого типа объектов. var proxy = new Proxy(); proxy.RequestChannel()

### Поведенческие

**Chain of Response** Избегает связи отправителя с приемником, давая объекту возможность для обработки запроса. Employee.SetSupervisor(Manager); Manager.SetSupervisor(Director); Employee.Execute();

**Command** Инкапсулирует запрос в виде объекта с поддержкой различных команд. Command.DoSomething(); Command.Redo(); Command.Undo();

**Interpreter** Определяет представление с помощью языковых возможностей (например используется в регулярных выражениях или в некоторых реализациях шаблона Flyweight) Vocabulary.Add(expressionA); Vocabulary.Add(expressionB); Vocabulary.Translate();

**Mediator** Определяет объект, который инкапсулирует в себе набор объектов, которые могут взаимодействовать. Mediator.Add(ObjA); Mediator.Add(ObjB); ObjA.Send(“ObjB”, "Message");

**Memento** Не нарушая инкапсуляции, сохраняет внутреннее состояние объекта таким образом, что объект может быть восстановлены в этом состоянии позже (используется, например, при сериализации объектов или в LINQ to Entities). ObjA.Name = “ObjA"; Memento.Save(ObjA); Memento.Restore(ObjA);

**Observer** Определяет отношение между объектами "один-ко-многим", так что когда один объект изменяется, все его дочерние объекты получают информацию об этом и автоматически обновляются. Observer.Attach(ObjA);Observer.Attach(ObjB); Observer.ChangeSomething(); Observer.Notify();

**State** Позволяет объекту изменять свое поведение когда изменяется его внутреннее состояние. Context.Add(ObjA); ObjA.ChangeState(“A"); ObjA.ChangeState(“B”);

**Strategy** Определяет несколько алгоритмов для работы с наборами объектов. List.Add(ObjA); List.Add(ObjB); List.SortStrategy(Ascending); List.SortStrategy(Descending);

**Template** Method Определяет структуру алгоритма внутри метода, при этом поведение зависит от типа класса экземпляра, переданного этому методу. Template A = new Student(); Template B = new Teacher(); A.Write(); B.Write();
Visitor Добавляет метод, для работы со структурой объектов. List.Add(Student(“A”)); List.Add(Student(“B”)); List.Visit(new VoteVisitor());
